<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blocking I/O Explained: Why It Wastes CPU</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        h2 {
            color: #667eea;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        h3 {
            color: #333;
            margin: 20px 0 10px 0;
        }

        .thread-diagram {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin: 20px 0;
        }

        .thread-box {
            background: #f8f9fa;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 20px;
        }

        .thread-header {
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #667eea;
        }

        .thread-steps {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .step {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border-left: 5px solid #27ae60;
        }

        .step.blocking {
            border-left-color: #e74c3c;
            background: #fff5f5;
            animation: pulse-block 2s infinite;
        }

        @keyframes pulse-block {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .step-icon {
            font-size: 2em;
            min-width: 40px;
            text-align: center;
        }

        .step-content {
            flex: 1;
        }

        .step-title {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .step-desc {
            color: #666;
            font-size: 0.9em;
        }

        .step-time {
            font-weight: bold;
            color: #e74c3c;
            min-width: 80px;
            text-align: right;
        }

        .step-time.good {
            color: #27ae60;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            margin: 15px 0;
            line-height: 1.6;
        }

        .comment {
            color: #95a5a6;
        }

        .highlight {
            background: #e74c3c;
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .highlight-good {
            background: #27ae60;
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .cpu-visualization {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .cpu-core {
            width: 200px;
            height: 300px;
            background: #f8f9fa;
            border: 3px solid #333;
            border-radius: 10px;
            padding: 15px;
            position: relative;
        }

        .cpu-title {
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .cpu-bar {
            width: 100%;
            height: 40px;
            margin: 5px 0;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
        }

        .cpu-working {
            background: #27ae60;
        }

        .cpu-blocked {
            background: #e74c3c;
            animation: blocked-shake 0.5s infinite;
        }

        @keyframes blocked-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        .cpu-idle {
            background: #95a5a6;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-box {
            padding: 20px;
            border-radius: 10px;
        }

        .comparison-box.bad {
            background: #fff5f5;
            border: 3px solid #e74c3c;
        }

        .comparison-box.good {
            background: #f0fff4;
            border: 3px solid #27ae60;
        }

        .comparison-title {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }

        .comparison-box.bad .comparison-title {
            color: #e74c3c;
        }

        .comparison-box.good .comparison-title {
            color: #27ae60;
        }

        .analogy {
            background: #fffacd;
            border-left: 5px solid #f39c12;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .analogy-title {
            font-weight: bold;
            color: #f39c12;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .timeline {
            margin: 20px 0;
        }

        .timeline-bar {
            height: 60px;
            display: flex;
            border-radius: 8px;
            overflow: hidden;
            margin: 10px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .timeline-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
            text-align: center;
            padding: 5px;
        }

        .timeline-segment.block {
            background: #e74c3c;
        }

        .timeline-segment.work {
            background: #27ae60;
        }

        @media (max-width: 768px) {
            .comparison-grid {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîí Blocking I/O: Why It Wastes CPU Cycles</h1>

        <div class="card">
            <h2>Phase 7 Thread Architecture</h2>

            <h3>Total Threads: 17</h3>
            <ul style="margin: 15px 0; line-height: 2;">
                <li><strong>1 Accept Thread</strong> - Dedicated to accepting new connections</li>
                <li><strong>16 Worker Threads</strong> - Thread pool handling requests (Phase 6 optimization)</li>
            </ul>

            <div class="thread-diagram">
                <div class="thread-box">
                    <div class="thread-header">üéØ Thread #1: Accept Thread (Main Loop)</div>
                    <div class="thread-steps">
                        <div class="step blocking">
                            <div class="step-icon">üîí</div>
                            <div class="step-content">
                                <div class="step-title">accept(listen_fd, ...)</div>
                                <div class="step-desc">BLOCKS waiting for a new client connection. This thread sits idle until a client connects!</div>
                            </div>
                            <div class="step-time">~2ms per connection</div>
                        </div>
                        <div class="step">
                            <div class="step-icon">‚û°Ô∏è</div>
                            <div class="step-content">
                                <div class="step-title">Enqueue to Thread Pool</div>
                                <div class="step-desc">Pass the client socket to worker thread</div>
                            </div>
                            <div class="step-time good">~0.01ms</div>
                        </div>
                        <div class="step blocking">
                            <div class="step-icon">üîÅ</div>
                            <div class="step-content">
                                <div class="step-title">Loop back to accept()</div>
                                <div class="step-desc">Go back to blocking on accept() again!</div>
                            </div>
                            <div class="step-time">Forever...</div>
                        </div>
                    </div>
                </div>

                <div class="thread-box">
                    <div class="thread-header">‚öôÔ∏è Threads #2-17: Worker Thread Pool (one example)</div>
                    <div class="thread-steps">
                        <div class="step blocking">
                            <div class="step-icon">üîí</div>
                            <div class="step-content">
                                <div class="step-title">read(client_fd, buffer, 4096)</div>
                                <div class="step-desc">BLOCKS waiting for HTTP request data to arrive over network. Thread sleeps until data ready!</div>
                            </div>
                            <div class="step-time">~3ms</div>
                        </div>
                        <div class="step">
                            <div class="step-icon">‚öôÔ∏è</div>
                            <div class="step-content">
                                <div class="step-title">parse_request(data)</div>
                                <div class="step-desc">Parse HTTP headers and JSON - ACTUAL CPU WORK!</div>
                            </div>
                            <div class="step-time good">~0.5ms</div>
                        </div>
                        <div class="step">
                            <div class="step-icon">‚úÖ</div>
                            <div class="step-content">
                                <div class="step-title">validate_and_process()</div>
                                <div class="step-desc">Business logic - ACTUAL CPU WORK!</div>
                            </div>
                            <div class="step-time good">~0.5ms</div>
                        </div>
                        <div class="step blocking">
                            <div class="step-icon">üîí</div>
                            <div class="step-content">
                                <div class="step-title">write(disk_fd, metrics, len)</div>
                                <div class="step-desc">BLOCKS waiting for disk to write. Thread sleeps until disk operation completes!</div>
                            </div>
                            <div class="step-time">~3ms</div>
                        </div>
                        <div class="step">
                            <div class="step-icon">üì§</div>
                            <div class="step-content">
                                <div class="step-title">write(client_fd, response, len)</div>
                                <div class="step-desc">Send HTTP response back to client</div>
                            </div>
                            <div class="step-time good">~0.5ms</div>
                        </div>
                        <div class="step">
                            <div class="step-icon">üîÅ</div>
                            <div class="step-content">
                                <div class="step-title">Thread returns to pool</div>
                                <div class="step-desc">Wait for next task from queue</div>
                            </div>
                            <div class="step-time good">~0.01ms</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="timeline">
                <h3>Time Breakdown for ONE Request (Worker Thread)</h3>
                <div class="timeline-bar">
                    <div class="timeline-segment block" style="flex: 3;">
                        üîí read()<br>3ms BLOCKED
                    </div>
                    <div class="timeline-segment work" style="flex: 0.5;">
                        ‚öôÔ∏è parse<br>0.5ms
                    </div>
                    <div class="timeline-segment work" style="flex: 0.5;">
                        ‚úÖ validate<br>0.5ms
                    </div>
                    <div class="timeline-segment block" style="flex: 3;">
                        üîí write(disk)<br>3ms BLOCKED
                    </div>
                    <div class="timeline-segment work" style="flex: 0.5;">
                        üì§ respond<br>0.5ms
                    </div>
                </div>
                <p style="text-align: center; margin-top: 15px; font-size: 1.1em;">
                    <strong>Total: 7.5ms</strong> |
                    <span style="color: #e74c3c;">6ms BLOCKED (80%)</span> +
                    <span style="color: #27ae60;">1.5ms WORKING (20%)</span>
                </p>
            </div>
        </div>

        <div class="card">
            <h2>‚ùì Why Does Blocking Waste CPU Cycles?</h2>

            <div class="analogy">
                <div class="analogy-title">üçï The Restaurant Analogy</div>
                <p style="line-height: 1.8;">
                    <strong>Blocking I/O:</strong> You have a chef who places an order with the supplier,
                    then <strong>stands at the door doing nothing</strong> until the delivery arrives (5 minutes!).
                    The chef can't cook other dishes while waiting. <strong>You'd need 50 chefs
                    standing around waiting</strong> to serve 50 customers!
                </p>
                <p style="line-height: 1.8; margin-top: 10px;">
                    <strong>Event-Driven I/O:</strong> Chef places the order and goes back to cooking.
                    When delivery arrives, the doorbell rings and chef picks it up instantly.
                    <strong>One chef can handle 50 customers efficiently</strong> because they're never idle!
                </p>
            </div>

            <h3>The Technical Reality</h3>

            <div class="comparison-grid">
                <div class="comparison-box bad">
                    <div class="comparison-title">‚ùå What "BLOCKED" Really Means</div>
                    <div class="code-block">
// Thread calls read()
int bytes = read(fd, buffer, 4096);

// What happens in the kernel:
1. Thread says "I need data from socket"
2. Kernel says "data not ready yet"
3. <span class="highlight">Thread goes to SLEEP</span>
4. CPU context switches to another thread
5. ... time passes ...
6. Network card receives data
7. Kernel wakes up the thread
8. Thread gets scheduled back on CPU
9. read() finally returns
                    </div>

                    <ul style="margin: 15px 0; line-height: 1.8;">
                        <li><strong>Thread is put to SLEEP</strong> by the OS</li>
                        <li><strong>Context switch overhead</strong> (~1-5 microseconds each time)</li>
                        <li><strong>Thread stack remains in memory</strong> (8MB per thread!)</li>
                        <li><strong>CPU can't use this thread</strong> for other work</li>
                    </ul>
                </div>

                <div class="comparison-box good">
                    <div class="comparison-title">‚úÖ Non-Blocking (Event-Driven)</div>
                    <div class="code-block">
// Event loop uses epoll_wait()
events = epoll_wait(epoll_fd, ...);

// What happens in the kernel:
1. Tell kernel: "notify me when ANY socket has data"
2. <span class="highlight-good">Thread sleeps efficiently</span>
3. <span class="highlight-good">Zero memory waste</span> (just event queue)
4. Network card receives data
5. <span class="highlight-good">Kernel instantly wakes ONE thread</span>
6. Thread processes ALL ready events
7. read() returns IMMEDIATELY (data ready!)
                    </div>

                    <ul style="margin: 15px 0; line-height: 1.8;">
                        <li><strong>One thread handles 1000s of connections</strong></li>
                        <li><strong>Minimal context switching</strong></li>
                        <li><strong>4KB per connection</strong> (not 8MB!)</li>
                        <li><strong>CPU only works when data is ready</strong></li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>üñ•Ô∏è CPU Utilization Comparison</h2>

            <div class="cpu-visualization">
                <div class="cpu-core">
                    <div class="cpu-title">Phase 7 (Blocking)</div>
                    <div style="margin-top: 20px;">
                        <div class="cpu-bar cpu-blocked">Thread 1: BLOCKED</div>
                        <div class="cpu-bar cpu-blocked">Thread 2: BLOCKED</div>
                        <div class="cpu-bar cpu-working">Thread 3: Working</div>
                        <div class="cpu-bar cpu-blocked">Thread 4: BLOCKED</div>
                        <div class="cpu-bar cpu-blocked">Thread 5: BLOCKED</div>
                    </div>
                    <p style="text-align: center; margin-top: 20px; color: #e74c3c; font-weight: bold;">
                        4/5 threads idle<br>
                        80% WASTED!
                    </p>
                </div>

                <div class="cpu-core">
                    <div class="cpu-title">Phase 8 (Event-Driven)</div>
                    <div style="margin-top: 20px;">
                        <div class="cpu-bar cpu-working">Event Loop: Active</div>
                        <div class="cpu-bar cpu-working">Worker 1: Parsing</div>
                        <div class="cpu-bar cpu-working">Worker 2: Parsing</div>
                        <div class="cpu-bar cpu-working">Worker 3: Parsing</div>
                        <div class="cpu-bar cpu-idle">Worker 4: Idle (ok!)</div>
                    </div>
                    <p style="text-align: center; margin-top: 20px; color: #27ae60; font-weight: bold;">
                        4/5 working<br>
                        80% EFFICIENCY!
                    </p>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>üìä The Numbers Don't Lie</h2>

            <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                <thead>
                    <tr style="background: #667eea; color: white;">
                        <th style="padding: 15px; text-align: left;">Metric</th>
                        <th style="padding: 15px; text-align: center;">Phase 7 (Blocking)</th>
                        <th style="padding: 15px; text-align: center;">Phase 8 (Event-Driven)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr style="background: #f8f9fa;">
                        <td style="padding: 15px;"><strong>Threads Needed for 200 Clients</strong></td>
                        <td style="padding: 15px; text-align: center; color: #e74c3c;">~200 threads (1 per client)</td>
                        <td style="padding: 15px; text-align: center; color: #27ae60;">1 event loop + 16 workers</td>
                    </tr>
                    <tr>
                        <td style="padding: 15px;"><strong>Memory Overhead</strong></td>
                        <td style="padding: 15px; text-align: center; color: #e74c3c;">1.6 GB (200 √ó 8MB)</td>
                        <td style="padding: 15px; text-align: center; color: #27ae60;">800 KB (200 √ó 4KB)</td>
                    </tr>
                    <tr style="background: #f8f9fa;">
                        <td style="padding: 15px;"><strong>Context Switches per Second</strong></td>
                        <td style="padding: 15px; text-align: center; color: #e74c3c;">~10,000+ (very high)</td>
                        <td style="padding: 15px; text-align: center; color: #27ae60;">~100 (minimal)</td>
                    </tr>
                    <tr>
                        <td style="padding: 15px;"><strong>CPU Efficiency</strong></td>
                        <td style="padding: 15px; text-align: center; color: #e74c3c;">20% (80% blocked)</td>
                        <td style="padding: 15px; text-align: center; color: #27ae60;">95%+ (minimal idle)</td>
                    </tr>
                    <tr style="background: #f8f9fa;">
                        <td style="padding: 15px;"><strong>Max RPS Achieved</strong></td>
                        <td style="padding: 15px; text-align: center; color: #e74c3c;">2,253</td>
                        <td style="padding: 15px; text-align: center; color: #27ae60;">145,348</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="card">
            <h2>üéØ Key Takeaways</h2>

            <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; line-height: 1.8;">
                <h3 style="color: #e74c3c; margin-top: 0;">Why Blocking Wastes CPU:</h3>
                <ol style="margin: 15px 0 15px 30px;">
                    <li><strong>Threads sleep</strong> waiting for I/O, but still consume memory (8MB stack)</li>
                    <li><strong>Context switching</strong> overhead when OS switches between blocked threads</li>
                    <li><strong>Limited concurrency</strong> - one thread per connection doesn't scale</li>
                    <li><strong>CPU does nothing</strong> during blocking - could be serving other requests!</li>
                </ol>

                <h3 style="color: #27ae60;">Why Event-Driven Wins:</h3>
                <ol style="margin: 15px 0 15px 30px;">
                    <li><strong>OS notifies</strong> only when data is ready - zero polling waste</li>
                    <li><strong>One thread</strong> can monitor thousands of connections via epoll</li>
                    <li><strong>Minimal memory</strong> - 4KB per connection vs 8MB per thread</li>
                    <li><strong>CPU works 100%</strong> of the time it's scheduled - no blocking!</li>
                </ol>

                <p style="margin-top: 20px; padding: 20px; background: #fffacd; border-radius: 8px; border-left: 5px solid #f39c12;">
                    <strong>üí° Bottom Line:</strong> In blocking I/O, threads spend 80% of their time <em>waiting</em>.
                    In event-driven I/O, the thread only runs when there's actual work to do.
                    This is why nginx can serve 10,000+ concurrent connections while Apache (blocking model)
                    struggles beyond a few hundred.
                </p>
            </div>
        </div>
    </div>
</body>
</html>
